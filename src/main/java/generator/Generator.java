package generator;

import javassist.*;
import utils.ClazzFileContainer;

import java.io.IOException;

import utils.ClazzLogger;
import utils.FieldVarType;

/**
 * capable of generating the smallest executable class-file
 */
public class Generator {
    static final int MAX_LOCALS = 100;
    static final int MAX_GLOBALS = 100;
    static final int MAX_METHODS = 100;
    static final int MAX_METHOD_CALLS = 100;

    private ClazzFileContainer clazzContainer;

    /**
     * Takes an existing utils.ClazzFileContainer to extend
     *
     * @param cf the container for the class-file with additional information
     */
    public Generator(ClazzFileContainer cf) {
        this.clazzContainer = cf;
    }

    /**
     * creates a generator.Generator with a new utils.ClazzFileContainer
     *
     * @param filename name of the class-file to be generated
     */
    public Generator(String filename) {
        this.clazzContainer = new ClazzFileContainer(filename);
    }

    /**
     * creates a generator.Generator with a new utils.ClazzFileContainer with a default filename
     */
    public Generator() {
        this.clazzContainer = new ClazzFileContainer("GenClazz");
    }

    public ClazzFileContainer getClazzContainer() {
        return clazzContainer;
    }


    /**
     * checks compatibility of given value and fieldtype
     *
     * @param value the value to check compatibility for
     * @param type  the type to which value is checked for compatibility
     * @return {@code true} if value is assignable to a field of given type, otherwise {@code false}
     */
    static boolean isAssignable(Object[] value, FieldVarType type) {
        if (value.length == 0) return false;
        if (value.length == 1) {
            switch (type) {
                case Byte:
                    return value[0] instanceof Byte;
                case Short:
                    return value[0] instanceof Short;
                case Int:
                    return value[0] instanceof Integer;
                case Long:
                    return value[0] instanceof Long;
                case Float:
                    return value[0] instanceof Float;
                case Double:
                    return value[0] instanceof Double;
                case Boolean:
                    return value[0] instanceof Boolean;
                case Char:
                    return value[0] instanceof Character;
                case String:
                    return value[0] instanceof String;
                default:
                    return false;
            }
        } else return false;
    }

    static boolean isCompatibleTo(FieldVarType type1, FieldVarType type2) {
        switch (type1) {
            case Byte:
                if (type2 == FieldVarType.Byte) return true;
                break;
            case Short:
                if (FieldVarType.getCompWithShort().contains(type2)) return true;
                else return false;
            case Int:
                if (FieldVarType.getCompWithInt().contains(type2)) return true;
                else return false;
            case Long:
                if (FieldVarType.getCompWithLong().contains(type2)) return true;
                else return false;
            case Float:
                if (type2 == FieldVarType.Float) return true;
                else return false;
            case Double:
                if (FieldVarType.getCompWithDouble().contains(type2)) return true;
                else return false;
            case Boolean:
                if (type2 == FieldVarType.Boolean) return true;
                else return false;
            case Char:
                if (type2 == FieldVarType.Char) return true;
                else return false;
            case String:
                if (type2 == FieldVarType.String) return true;
                else return false;
        }
        return false;
    }

    /**
     * @return the class-file of this generator
     */
    public CtClass getClazzFile() {
        return clazzContainer.getClazzFile();
    }

    public CtMethod getMain() {
        return this.getMethod("main");
    }

    /**
     * write the CtClass-Object as a .class file
     */
    public void writeFile() {
        try {
            this.getClazzFile().writeFile();
        } catch (NotFoundException | IOException | CannotCompileException e) {
            System.err.println("Cannot write class-file");
            e.printStackTrace();
        }
    }

    /**
     * @return the ClazzLogger-Object of the class, generated by this Generator
     */
    public ClazzLogger getClazzLogger() {
        return this.clazzContainer.getClazzLogger();
    }

    static boolean validateModifiers(int[] modifiers) {
        int numberOfAccessModifiers = 0;
        for (int m : modifiers) {
            switch (m) {
                case Modifier.STATIC:
                    break;
                case Modifier.PUBLIC:
                    numberOfAccessModifiers++;
                    break;
                case Modifier.PRIVATE:
                    numberOfAccessModifiers++;
                    break;
                case Modifier.PROTECTED:
                    numberOfAccessModifiers++;
                    break;
                case Modifier.FINAL:
                    break;
                default:
                    return false;
            }
        }
        if (numberOfAccessModifiers > 1) return false;
        else return true;
    }

    /**
     * @param methodName the name of the method to return
     * @return CtMethod-Object of the method with given name, null if this method does not exist
     */
    public CtMethod getMethod(String methodName) {
        if (this.getClazzLogger().hasMethod(methodName)) {
            try {
                return this.getClazzFile().getDeclaredMethod(methodName);
            } catch (NotFoundException e) {
                System.err.println("Method " + methodName + " not found");
                e.printStackTrace();
                return null;
            }
        } else {
            System.err.println("Method " + methodName + " does not exist in the generated class");
            return null;
        }
    }

    static int mergeModifiers(int[] modifiers) {
        int merged_modifiers = modifiers[0];
        for (int i = 1; i < modifiers.length; i++) {
            merged_modifiers |= modifiers[i];
        }
        return merged_modifiers;
    }
}

